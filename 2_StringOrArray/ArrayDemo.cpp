#include <string>
#include <iostream>
#include <cstring>      // cstring是c语言头文件string.h的c++版本
#include <vector>

using std::string;
// 通过下列using声明, 可以在函数体内直接使用标准库的名字
using std::cout;
using std::cin;
using std::endl;

int main(int argc, char const *argv[]) {

        cout << "************************数组的初始化**************************************" << endl;
        //关于数组的初始化, 声明的数组大小, 必须是常量表达式, 如果数组的array[size]中使用了size那么size记得使用constexpr关键字修饰为常量
        //显示初始化数组
        const unsigned size = 5;
        int a1[size] = {1,3,5};           // 数组中有三个元素, 元素值分别为1,3,5
        int a2[] = {1,3,5};               // 长度是3的数组, 等价于上面
        int a3[5] = {1,3,5};              // 数组的长度为5, 等价于 = {1,3,5,0,0}

        //字符数组的特殊性
        char c1[] = "c++";                // 长度应该是4, 因为字符串包含着一个空字符等价于 = {'c','+','c','\0'}

        // 数组的内容不能拷贝到其他数组作为初始值, 也不能为其赋值例如
        // int a4 = a1;  a4 = a1;         // 这都是错误的

        // 比较复杂的数组声明
        int *ptrs[10];                    // ptrs 表示一个含有10个整型指针的数组对象  ==> 理解为数组的对象类型为int*
            //int &refs[10];              // 这是一个错误事例, 因为不存在元素对象是引用类型的数组
        int (*Parray)[5] = &a1;           // 首先parray表明是一个指针对象, 指向的是一个int类型长度为5的数组, 所以右侧需要对一个对象使用接地址符来获取指针
        int (&arrRef)[5] = a1;            // 首先parray表明是一个引用, 引用的是一个int类型 长度为5 的数组, 因为是引用对象, 所以右侧直接赋值一个同样类型对象即可
            // int *(&array)[10]= ptrs;   // array是一个数组的引用, 然后该数组的类型是int指针

        cout << "************************指针和数组**************************************" << endl;
        // 使用数组的时候编译器一般会把它转换成指针
        // 通常取地址符(&)可以获取指向某个对象的指针, 取地址符可以用于任何对象, 数组的元素也是对象, 对数组使用下标运算符得到该数组指定的元素,
        // 其本质也是对象, 所以同样可以对数组元素使用取地址符来得到其指针 . 例如
        string nums[] = {"one", "two", "three"};
        string *p = &nums[0];             // p是一个指针类型, 指向nums的第一个元素

        // 数组还有一个特性, 当对使用到数组名字的地方, 编译器都会自动地将其转换成一个指向数组首元素的指针.
        string *p2 = nums;                // 等价于*p2 = &nums[0]
        // 同理
        auto sa(nums);                    // 当使用一个数组作为一个auto变量的初始值时, 推断得到的类型是指针而非数组, sa的类型是一个指向数组第一个元素的字符串类型指针.
        *sa = "zero";
        cout << "输出数组的第一个元素, 查看是否改变: " << nums[0] << endl;

        //  指针和迭代器的关联
        // 指向数组的指针拥有更多的功能, vector和string支持的运算, 数组的指针全部支持. 例如使用递增运算来移动指针指向数组的下一个元素
        int arr[] = {0,1,2,3,4,5};
        int *p1 = arr;                     // p是指向数组第一个元素的指针
        p1++;                              // p指向的是数组的第二个元素的指针

        // 利用尾后指针来循环数组, 同尾后迭代器一样, 尾后指针也不指向具体的元素, 因为不可以对尾后指针执行解引用或递增的操作
        // 1. 首先获得判断条件 尾后指针
        int *end = &arr[6];
        // 2. 开始循环遍历数组
        for(int *start = arr; start!=end ; start++ ){
            cout << "   " << *start ;
        }
        cout << endl;

        // 计算得到的尾后指针容易出错, 所以c++11中引入了 begin 和end函数, 虽然和vector功能类似, 但是数组毕竟不是类类型,
        // 因此这两个函数不是成员函数, 正确的使用形式是将数组作为他们的参数.
        int *pbeg = std::begin(arr), *pend = std::end(arr);     // pbeg指向arr的首元素, pend指向arr为元素的下一个位置
        while(pbeg != pend){
            cout << "   " << *pbeg ;
            pbeg++;
        }
        cout << endl;

        cout << "************************指针的运算**************************************" << endl;
        const std::size_t lenght = 5;
        int arr9[lenght] = {1,2,3,4,5};
        int *intp = arr9;                      // 等价于int *p = &arr[0]
        int *intp2 = intp + 4;                // intp2指向arr[4]
        // 给一个指针加上一个整数值, 其结果还是一个指针, 新指针指向的元素与原来的指针相比前进或者后退了该整数值个位置.

        // 和迭代器一样, 两个指针相减的结果是他们之间的距离. 参与运算的两个指针必须指向同一个数组当中的元素.
        // 当两个指针相减的结果的类型是一种 ptrdiff_t 的标准库类型, 和size_t一样, 都是定义在 cstddef头文件中的机器相关的类型. 因为差值可能为负值, 所欲是带符号类型
        cout << "数组arr9的大小为: " << std::end(arr9)- std::begin(arr9) << endl;

        // 关于解引用和指针运算需要注意先后顺序
        // 例如arr9数组 {1,2,3,4,5}
        int tempArr[] = {0,2,4,6,8};
        int last_1 = *(tempArr + 4);        // 结果:8 首先右侧tempArr是一个指针类型指向数组第一个元素, +4代表指针向下移动4个位置, 指向了数组的下标为4的元素, 然后执行解引用
        int last_2 = *tempArr + 4;          // 结果:4 首先对指针类型进行解引用, 取得数组的第一个元素对象其值为0, 然后进行普通加法运算 0+4
        cout << "last_1=" << last_1 << "    last_2=" << last_2 << endl;

        // 了解数组下标的真实实现
        // 使用数组下标的形式, 其实本质上用的就是指向数组首元素的指针, 编译器会进行这些步骤的自动转换操作
        int tempInt = tempArr[2];           // 1.tempArr转换成了指向数组第一个元素的指针
                                            // 2.tempArr[2]得到(tempArr+2)所指的元素
        int *tempP = &tempArr[2];           // tempP指向索引为2的元素
        int j = tempP[1];                   // tempP[1] ==> *(temp+1), 就是对应的tempArr[3]
        int k = tempP[-1];                  // 根据上面的转换, 对应tempArr[1]
        cout << "下标的元素的传递计算  j=" << j << "  k=" << k << endl;
        // 这里要注意虽然string和vector也可以下标运算, 但是数组和他们稍有区别, 标准库类型限定使用的下标必须是无符号类型,
        // 而内置的下标运算无此要求, 所以直观来说: 数组的下标可以为负值, 是有符号类型; 而string和vector必须是正数,无符号类型

        cout << "************************c风格的字符串**************************************" << endl;
        // c风格的字符串不是一种类型, 而是为了表达和使用字符串而形成的一种约定俗成的写法.
        // 按照此书写的字符串存放在字符数组中并以空字符结束, '\0'
        char ca[] = {'c', '+', '+', '\0'};
        cout << "利用c风格字符串来获取字符串长度:" <<std::strlen(ca) << endl;

        // c风格字符串比较大小
        const char ca1[] = "abc";
        const char ca2[] = "abd";
        // 不可以使用if(ca1>ca2)来判断, 因为当使用数组的时候其实默认是指向数组的首元素指针, 并且彼此是毫无关系的两个地址, 所以无法进行比较.
        if(std::strcmp(ca1,ca2) > 0){   // 如果前面的字符串比较大, 那么就返回正值
            cout << "ca1字符串较大" << endl;
        }else{
            cout<< "ca2字符串较大" << endl;
        }

        // c风格中对字符串的链接和拷贝
        char largeStr[10];
        std::strcpy(largeStr, ca1);         //字符串进行拷贝
        std::strcat(largeStr, ca2);         //字符串进行连接
        cout << "使用c风格字符串连接方法结果: " << largeStr << endl;

        // 任何出现字符串字面值的地方都可以使用以空字符结束的字符数组来替代
        // 这是c++为了兼容之前的c风格的字符串
        string composeStr (ca1);

        // 使用数组初始化vector对象,
        // 虽然不允许使用一个数组为另一个内置类型的数组赋初始值, 也不允许使用vector对象初始化数组. 当相反却可以.
        // 可以使用数组来初始化vector对象, 要完成这样的目的, 只需要指明要拷贝区域的首元素地址和尾后地址即可.
        std::vector<int> iVector(std::begin(tempArr), std::end(tempArr));
        // 如果需要拷贝数组下标1,2,3的元素, 可以直接利用数组名本质为指针的特性来进行赋值初始化
        std::vector<int> iSubVector(tempArr+1, tempArr+4);

        cout << "************************多维数组**************************************" << endl;
        // 准确的讲, c++语言中没有多维数组, 通常所说的所谓数组其实就是数组的数组.
        int iMulArr[3][4];          // 大小为3的数组, 每个元素是含有4个整数的数组
                                    // 对于二维数组, 常把第一个维度称作行, 第二个维度称作列.

        // 多维数组的初始化
        int iMulArr_1[3][4] = {
            {0,1,2,3},              // 第一行
            {4,5,6,7},              // 第二行
            {8,9,10,11}             // 第三行
        };
        // 上面的等号右侧 ==> {0,1,2,3,4,5,6,7,8,9,10,11};

        // 也可以显式初始化每行的首元素
        int iMulArr_2[3][4] = {{1},{2},{3}};
        // 显式的初始化第一行, 其他元素执行值初始化
        int iMulArr_3[3][4] = {1,2,3,4};

        // 多维数组的下标引用
        int (&row)[4] = iMulArr_1[1];   // 首先把row定义成一个含有4个整数的数组的引用, 然后将其绑定到iMulArr_1的第二行.

        // 使用for循环来获取多维数组的个数
        int tempNum = 0;
        for(auto &row : iMulArr_1){
            for(auto &col : row){
                tempNum++;
            }
        }
        cout << "使用引用方式对于二维数组iMulArr_1的总元素是: " << tempNum << endl;

        tempNum = 0;
        // 使用指针的形式遍历元素的个数
        for(auto p = iMulArr_1 ; p != std::end(iMulArr_1) ; p++){
            for (auto q = *p; q != std::end(*p) ; q++) {
                tempNum ++;
            }
        }
        cout << "使用指针方式对于二维数组iMulArr_1的总元素是: " << tempNum << endl;

    return 0;
}
